<!--
  Virtual Dive ‚Äì HNLMS K XI (1946)
  -------------------------------------------------------
  ‚Ä¢ Desktop/phone: Orbit drag & scroll.
  ‚Ä¢ Quest 2 VR   : Thumbsticks to fly/turn.
  ‚Ä¢ Even lighting; KTX2, Draco & Meshopt decoding wired.
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Virtual Dive ‚Äì HNLMS K XI</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#111;color:#eee;font-family:sans-serif}
  #info{position:absolute;top:10px;left:10px;z-index:10;background:rgba(0,0,0,.55);padding:6px 10px;border-radius:6px;font-size:13px;line-height:1.3em;max-width:300px}
  #modelSelector{position:absolute;top:10px;right:10px;z-index:10;background:rgba(0,0,0,.8);border-radius:6px;border:1px solid rgba(255,255,255,.2)}
  #modelCredit{position:absolute;top:50px;right:10px;z-index:10;background:rgba(0,0,0,.65);padding:4px 8px;border-radius:4px;font-size:11px;text-align:center;color:#999;border:1px solid rgba(255,255,255,.1)}
  #modelSelector select{background:transparent;color:#eee;border:none;padding:8px 12px;font-size:20.8px;font-family:sans-serif;cursor:pointer;outline:none}
  #modelSelector select option{background:#222;color:#eee}
  a{color:#87cefa;text-decoration:none}
</style>
<script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.module.js"}}</script>
</head>
<body>
<div id="info">
  <strong>VR:</strong> Thumbsticks to move/fly/turn<br>
  <strong>Desktop:</strong> Drag to orbit | Scroll to zoom | Double-click to focus
</div>

<div id="modelSelector">
  <select id="modelDropdown">
  </select>
</div>

<div id="modelCredit">
  <span id="creditText">Model by WreckSploration</span>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader }  from 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/loaders/DRACOLoader.js';
import { KTX2Loader }  from 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/loaders/KTX2Loader.js';
import { MeshoptDecoder } from 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/libs/meshopt_decoder.module.js';
import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/webxr/VRButton.js';
import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/webxr/XRControllerModelFactory.js';

// Device detection for VR optimization
let isQuest2 = false;
let isQuest3 = false;

// Function to detect Quest device type
function detectQuestDevice() {
  try {
    const userAgent = navigator.userAgent.toLowerCase();
    
    // Quest 2 detection patterns
    if (userAgent.includes('quest 2') || 
        userAgent.includes('oculus quest 2') ||
        (userAgent.includes('oculus') && userAgent.includes('android') && !userAgent.includes('quest 3'))) {
      isQuest2 = true;
      console.log('ü•Ω Quest 2 detected - applying performance optimizations');
      return 'quest2';
    }
    
    // Quest 3 detection patterns
    if (userAgent.includes('quest 3') || 
        userAgent.includes('oculus quest 3') ||
        userAgent.includes('meta quest 3')) {
      isQuest3 = true;
      console.log('ü•Ω Quest 3 detected - using full render distance');
      return 'quest3';
    }
    
    console.log('ü•Ω Unknown VR device or desktop - using default settings');
    return 'unknown';
  } catch (error) {
    console.warn('Device detection failed:', error);
    return 'unknown';
  }
}

// Function to apply Quest-specific optimizations
function applyQuestOptimizations(deviceType) {
  if (deviceType === 'quest2') {
    // Limit render distance to 20m for Quest 2 performance
    camera.far = 20;
    camera.updateProjectionMatrix();
    
    // Update fog to match reduced render distance
    scene.fog = new THREE.FogExp2(0x041729, 0.12); // Denser fog for 20m visibility
    
    console.log('üìä Quest 2 optimizations applied: 20m render limit, denser fog');
  } else {
    // Quest 3 or other devices - use full render distance
    camera.far = 2000;
    camera.updateProjectionMatrix();
    
    // Original fog settings
    scene.fog = new THREE.FogExp2(0x041729, 0.08);
    
    console.log('üìä Full render distance maintained: 2000m range');
  }
}

// ------------------------ Config ----------------------------
// Available models with display names and credits
const MODELS = {
  'kxi': { url: 'models/kxi.glb', name: 'HNLMS K XI (1946)', credit: 'WreckSploration' },
  'alextbrown': { url: 'models/alextbrown.glb', name: 'Alex T Brown', credit: 'Patrick Morrison' },
  'applecrossbarge': { url: 'models/applecrossbarge.glb', name: 'Applecross Barge', credit: 'Patrick Morrison & David Jackson' },
  'dentonholme': { url: 'models/dentonholme.glb', name: 'Denton Holme', credit: 'Patrick Morrison' },
  'key_biscayne': { url: 'models/key_biscayne.glb', name: 'Key Biscayne', credit: 'WreckSploration' },
  'mayfield': { url: 'models/mayfield.glb', name: 'Mayfield', credit: 'Patrick Morrison' },
  'pointwalter': { url: 'models/pointwalter.glb', name: 'Point Walter', credit: 'Patrick Morrison & David Jackson' },
  'sesa': { url: 'models/sesa.glb', name: 'Sesa', credit: 'WreckSploration' },
  'unknown': { url: 'models/unknown.glb', name: 'Unknown Wreck', credit: 'WreckSploration' }
};

let currentModelKey = 'kxi'; // Default model
const MODEL_URL = MODELS[currentModelKey].url;
const MOVE_SPEED = 2.0;    // m/s base movement speed
const TURN_SPEED = 1.5;    // rad/s turn speed
const FLY_SPEED = 1.0;     // m/s vertical movement

// Speed ramping variables
let currentSpeed = 0;      // Current ramped speed (0-1)
let targetSpeed = 0;       // Target speed (0-1)
let currentBoostLevel = 0; // Current boost level (0-1)
let targetBoostLevel = 0;  // Target boost level (0-1)
const SPEED_RAMP_RATE = 3.0;    // How fast speed ramps up/down (units per second)
const BOOST_RAMP_RATE = 4.0;    // How fast boost ramps up/down (units per second)

// Audio System for Movement Sounds
let audioContext = null;
let dpvSound = null;
let dpvHighSound = null;
let ambienceSound = null;
let currentMovementSound = null;
let currentBoostSound = null;
let currentAmbienceSound = null;
let baseGainNode = null;
let boostGainNode = null;
let ambienceGainNode = null;
let isMoving = false;

// Initialize audio system
async function initAudio() {
  try {
    // Create audio context
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Load DPV sounds and ambience
    const [dpvBuffer, dpvHighBuffer, ambienceBuffer] = await Promise.all([
      loadAudioBuffer('sound/dpv.ogg'),
      loadAudioBuffer('sound/dpvhigh.ogg'),
      loadAudioBuffer('sound/vrambience.ogg')
    ]);
    
    dpvSound = dpvBuffer;
    dpvHighSound = dpvHighBuffer;
    ambienceSound = ambienceBuffer;
    
    // Start ambient sound immediately
    startAmbienceSound();
    
    console.log('Audio system initialized successfully');
  } catch (error) {
    console.warn('Audio initialization failed:', error);
  }
}

// Load audio buffer from URL
async function loadAudioBuffer(url) {
  const response = await fetch(url);
  const arrayBuffer = await response.arrayBuffer();
  return await audioContext.decodeAudioData(arrayBuffer);
}

// Start ambient underwater sound
function startAmbienceSound() {
  if (!audioContext || !ambienceSound || currentAmbienceSound) return;
  
  try {
    const ambienceSource = audioContext.createBufferSource();
    ambienceGainNode = audioContext.createGain();
    
    ambienceSource.buffer = ambienceSound;
    ambienceSource.connect(ambienceGainNode);
    ambienceGainNode.connect(audioContext.destination);
    
    ambienceSource.loop = true;
    ambienceGainNode.gain.setValueAtTime(0.1, audioContext.currentTime); // Start at full volume - seamless loop
    
    ambienceSource.start();
    currentAmbienceSound = ambienceSource;
    
    console.log('Ambient underwater sound started');
  } catch (error) {
    console.warn('Error starting ambient sound:', error);
  }
}

// Stop ambient sound immediately - seamless loop
function stopAmbienceSound() {
  if (currentAmbienceSound && ambienceGainNode && audioContext) {
    try {
      currentAmbienceSound.stop();
      currentAmbienceSound = null;
      ambienceGainNode = null;
      console.log('Ambient sound stopped');
    } catch (error) {
      console.warn('Error stopping ambient sound:', error);
    }
  }
}

// Play movement sound with smooth audio setup
function playMovementSound() {
  if (!audioContext || !dpvSound || !dpvHighSound) return;
  
  // Stop current movement sounds if playing
  if (currentMovementSound) {
    currentMovementSound.stop();
    currentMovementSound = null;
  }
  if (currentBoostSound) {
    currentBoostSound.stop();
    currentBoostSound = null;
  }
  if (baseGainNode) {
    baseGainNode.disconnect();
  }
  if (boostGainNode) {
    boostGainNode.disconnect();
  }
  
  try {
    // Always create and play the base DPV sound
    const baseSource = audioContext.createBufferSource();
    baseGainNode = audioContext.createGain();
    
    baseSource.buffer = dpvSound;
    baseSource.connect(baseGainNode);
    baseGainNode.connect(audioContext.destination);
    
    baseSource.loop = true;
    baseGainNode.gain.setValueAtTime(0, audioContext.currentTime); // Start at 0 for smooth ramp
    
    baseSource.start();
    currentMovementSound = baseSource;
    
    // Create boost sound (always available for smooth transitions)
    const boostSource = audioContext.createBufferSource();
    boostGainNode = audioContext.createGain();
    
    boostSource.buffer = dpvHighSound;
    boostSource.connect(boostGainNode);
    boostGainNode.connect(audioContext.destination);
    
    boostSource.loop = true;
    boostGainNode.gain.setValueAtTime(0, audioContext.currentTime); // Start at 0
    
    boostSource.start();
    currentBoostSound = boostSource;
    
    console.log('Movement audio system started with smooth ramping');
  } catch (error) {
    console.warn('Error playing movement sound:', error);
  }
}

// Update audio volumes based on current speed and boost levels
function updateAudioLevels() {
  if (!baseGainNode || !boostGainNode || !audioContext) return;
  
  try {
    // Base volume scales with movement speed (increased by 1.3x again: 1.17 ‚Üí 1.52)
    const baseVolume = currentSpeed * 1.52;
    
    // Boost volume scales with boost level (increased by 1.3x again: 0.78 ‚Üí 1.01)
    const boostVolume = currentBoostLevel * 1.01;
    
    // Smooth volume transitions
    baseGainNode.gain.linearRampToValueAtTime(baseVolume, audioContext.currentTime + 0.1);
    boostGainNode.gain.linearRampToValueAtTime(boostVolume, audioContext.currentTime + 0.1);
    
  } catch (error) {
    console.warn('Error updating audio levels:', error);
  }
}

// Stop movement sound with smooth fade
function stopMovementSound() {
  if (baseGainNode && audioContext) {
    try {
      baseGainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);
      setTimeout(() => {
        if (currentMovementSound) {
          currentMovementSound.stop();
          currentMovementSound = null;
        }
      }, 250);
    } catch (error) {
      console.warn('Error stopping base movement sound:', error);
    }
  }
  
  if (boostGainNode && audioContext) {
    try {
      boostGainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);
      setTimeout(() => {
        if (currentBoostSound) {
          currentBoostSound.stop();
          currentBoostSound = null;
        }
        baseGainNode = null;
        boostGainNode = null;
      }, 250);
    } catch (error) {
      console.warn('Error stopping boost movement sound:', error);
    }
  }
}

// Initialize audio on user interaction (required for web audio)
let audioInitialized = false;
function initAudioOnInteraction() {
  if (!audioInitialized) {
    initAudio();
    audioInitialized = true;
  }
}

//-------------------------------------------------------------

// Scene basics
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x041729); // Much darker deep ocean blue

// Add underwater fog effect for ~15m visibility - darker and denser
scene.fog = new THREE.FogExp2(0x041729, 0.08); // Match darker background, slightly denser

const camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.05, 2000);
const dolly  = new THREE.Group(); dolly.add(camera); scene.add(dolly);

const renderer = new THREE.WebGLRenderer({antialias:true,powerPreference:'high-performance'});
renderer.setPixelRatio(Math.min(window.devicePixelRatio,1.5));
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.xr.enabled = true;

// Optimize renderer settings for faster loading/rendering
renderer.shadowMap.enabled = true; // Re-enable shadows for realistic lighting
renderer.shadowMap.type = THREE.VSMShadowMap; // Variance shadows reduce moire effects and banding
renderer.physicallyCorrectLights = false;
renderer.toneMapping = THREE.NoToneMapping;

// Reduce pixel ratio on mobile for better performance
if (window.devicePixelRatio > 2) {
  renderer.setPixelRatio(1.5);
}

document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

// Desktop orbit controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; 
controls.dampingFactor = 0.08;
controls.maxDistance = 100;
controls.minDistance = 0.5;

// Cancel focus animation when user manually controls camera
controls.addEventListener('start', () => {
  if (focusAnimation) {
    cancelAnimationFrame(focusAnimation);
    focusAnimation = null;
  }
});

// Raycaster for interactions
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// Double-click focus system
let lastClickTime = 0;
const DOUBLE_CLICK_TIME = 300;
let focusAnimation = null; // Track ongoing animation

window.addEventListener('resize',()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

// Mouse/touch interaction
renderer.domElement.addEventListener('click', onMouseClick);

// Add these variables near the top with other declarations
let isDragging = false;
let dragStartPosition = { x: 0, y: 0 };
const DRAG_THRESHOLD = 5; // pixels

// Add mouse event listeners for drag detection
renderer.domElement.addEventListener('mousedown', onMouseDown);
renderer.domElement.addEventListener('mousemove', onMouseMove);
renderer.domElement.addEventListener('mouseup', onMouseUp);

// Add audio initialization event listeners
renderer.domElement.addEventListener('click', initAudioOnInteraction);
renderer.domElement.addEventListener('keydown', initAudioOnInteraction);
renderer.domElement.addEventListener('touchstart', initAudioOnInteraction);

function onMouseDown(event) {
  isDragging = false;
  dragStartPosition.x = event.clientX;
  dragStartPosition.y = event.clientY;
}

function onMouseMove(event) {
  if (!isDragging) {
    const deltaX = Math.abs(event.clientX - dragStartPosition.x);
    const deltaY = Math.abs(event.clientY - dragStartPosition.y);
    
    if (deltaX > DRAG_THRESHOLD || deltaY > DRAG_THRESHOLD) {
      isDragging = true;
    }
  }
}

function onMouseUp(event) {
  // Reset drag state after a short delay to allow click event to process
  setTimeout(() => {
    isDragging = false;
  }, 10);
}

// Update the onMouseClick function for double-click focus only
function onMouseClick(event) {
  const currentTime = Date.now();
  const isDoubleClick = currentTime - lastClickTime < DOUBLE_CLICK_TIME;
  lastClickTime = currentTime;
  
  if (renderer.xr.isPresenting || isDragging) return; // Don't process when dragging
  
  if (isDoubleClick) {
    // Calculate mouse position
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    
    // Raycast from camera
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children, true);
    
    if (intersects.length > 0) {
      // Double-click: focus on point
      focusOnPoint(intersects[0].point);
    }
  }
}

function focusOnPoint(point) {
  // Cancel any existing focus animation
  if (focusAnimation) {
    cancelAnimationFrame(focusAnimation);
    focusAnimation = null;
  }
  
  const startTarget = controls.target.clone();
  const startPosition = camera.position.clone();
  
  // Calculate new camera position (maintain relative offset)
  const offset = startPosition.clone().sub(startTarget);
  const newPosition = point.clone().add(offset);
  
  // Smooth animation
  const duration = 1000; // 1 second
  const startTime = performance.now();
  
  function animate() {
    const elapsed = performance.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const eased = 1 - Math.pow(1 - progress, 3); // ease-out cubic
    
    controls.target.lerpVectors(startTarget, point, eased);
    camera.position.lerpVectors(startPosition, newPosition, eased);
    
    if (progress < 1) {
      focusAnimation = requestAnimationFrame(animate);
    } else {
      focusAnimation = null; // Animation complete
    }
  }
  
  focusAnimation = requestAnimationFrame(animate);
}

// Add extremely dim overhead lighting - just enough to see silhouettes
const overheadLight = new THREE.AmbientLight(0x1a3b5c, 0.005); // Very dim blue-tinted light
scene.add(overheadLight);

// Declare spotlight variables - will be created after model loading
let controllerSpotlight = null;
let spotlightTarget = null;

// Function to create/recreate the spotlight
function createSpotlight(beamWidthDegrees = 35) {
  // Remove existing spotlight if it exists
  if (controllerSpotlight) {
    scene.remove(controllerSpotlight);
    scene.remove(spotlightTarget);
  }
  
  // Convert degrees to radians
  const beamWidthRadians = (beamWidthDegrees * Math.PI) / 180;
  
  // Adjust spotlight distance based on Quest device for performance
  const spotlightDistance = isQuest2 ? 15 : 15; // Keep same distance for now, could reduce further if needed
  
  // Create new spotlight with configurable beam width
  controllerSpotlight = new THREE.SpotLight(
    0xffffff,        // Pure white light
    2.5,             // Realistic underwater torch intensity
    spotlightDistance, // Adjustable distance based on device
    beamWidthRadians, // Configurable beam width in radians
    0.15,            // Softer penumbra for more realistic falloff
    0.8              // Higher decay for realistic underwater attenuation
  );

  // Configure spotlight properties
  controllerSpotlight.position.set(0, 0, 0);
  controllerSpotlight.visible = false;
  controllerSpotlight.castShadow = true; // Enable shadow casting
  
  // Optimize shadow settings for VR performance and eliminate moire effects
  const shadowMapSize = isQuest2 ? 512 : 1024; // Reduce shadow quality on Quest 2
  controllerSpotlight.shadow.mapSize.width = shadowMapSize;
  controllerSpotlight.shadow.mapSize.height = shadowMapSize;
  controllerSpotlight.shadow.camera.near = 0.1;
  controllerSpotlight.shadow.camera.far = spotlightDistance; // Match spotlight distance
  controllerSpotlight.shadow.camera.fov = beamWidthDegrees; // Match spotlight angle
  
  // Fix shadow acne and moire effects with proper bias settings
  controllerSpotlight.shadow.bias = -0.0005; // Negative bias to prevent shadow acne
  controllerSpotlight.shadow.normalBias = 0.02; // Normal bias to reduce peter panning
  controllerSpotlight.shadow.radius = 4; // Softer shadow edges to reduce artifacts
  controllerSpotlight.shadow.blurSamples = 10; // More samples for smoother shadows

  // Add spotlight to scene
  scene.add(controllerSpotlight);

  // Create a simple target object for the spotlight
  spotlightTarget = new THREE.Object3D();
  scene.add(spotlightTarget);
  controllerSpotlight.target = spotlightTarget;

  console.log(`Spotlight created/recreated with ${beamWidthDegrees}¬∞ beam width, ${spotlightDistance}m distance, and ${shadowMapSize}px shadows:`, controllerSpotlight);
}

// Add underwater particles system - dynamically sized based on wreck
let particleCount = 1750; // Halved from 3500 - Initial default, will be recalculated per wreck
const particleGeometry = new THREE.BufferGeometry();
let particlePositions = new Float32Array(particleCount * 3);
let particleVelocities = new Float32Array(particleCount * 3);
let particleSizes = new Float32Array(particleCount); // Add size variation

// Particle boundary variables - will be set when wreck loads
let particleBounds = {
  min: new THREE.Vector3(-50, -25, -50),
  max: new THREE.Vector3(50, 25, 50)
};

// Function to calculate optimal particle count based on wreck size
function calculateParticleCount(wreckBounds) {
  const size = new THREE.Vector3();
  wreckBounds.getSize(size);
  
  // Calculate volume of the expanded particle field (2.5x wreck size)
  const expansion = 2.5;
  const expandedSize = size.clone().multiplyScalar(expansion);
  const volume = expandedSize.x * expandedSize.y * expandedSize.z;
  
  // Dynamic density scaling - much lower for small sites to avoid overcrowding
  // Small sites get very low density, medium sites scale up gradually, large sites maintain good density
  let targetDensity;
  if (volume < 5000) {
    // Small sites (e.g., 20x5m): 0.0625 particles/m¬≥ (3x reduction from original)
    targetDensity = 0.0625;
  } else if (volume < 20000) {
    // Medium sites: Scale from 0.0625 to 2.0 particles/m¬≥ 
    const scaleFactor = (volume - 5000) / 15000; // 0 to 1
    targetDensity = 0.0625 + (scaleFactor * 1.9375); // 0.0625 to 2.0
  } else {
    // Large sites (e.g., 70x15m): Keep good density at 3.5 particles/m¬≥
    targetDensity = 3.5;
  }
  
  const calculatedCount = Math.round(volume * targetDensity);
  
  // Clamp between reasonable limits - much lower minimum for small sites
  const minParticles = 100;   // Further reduced for small sites
  const maxParticles = 8000;  // Slightly reduced cap for performance
  const finalCount = Math.max(minParticles, Math.min(maxParticles, calculatedCount));
  
  console.log(`Wreck size: ${size.x.toFixed(1)}√ó${size.y.toFixed(1)}√ó${size.z.toFixed(1)}m`);
  console.log(`Particle field volume: ${volume.toFixed(1)}m¬≥`);
  console.log(`Calculated particles: ${calculatedCount} (${targetDensity.toFixed(1)}/m¬≥)`);
  console.log(`Final particle count: ${finalCount}`);
  
  return finalCount;
}

// Function to update particle boundaries based on wreck
function updateParticleBounds() {
  if (wreck) {
    const box = new THREE.Box3().setFromObject(wreck);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());
    
    // Calculate new particle count based on wreck size
    const newParticleCount = calculateParticleCount(box);
    
    // If particle count changed significantly, recreate the particle system
    if (Math.abs(newParticleCount - particleCount) > particleCount * 0.2) {
      console.log(`Recreating particle system: ${particleCount} ‚Üí ${newParticleCount} particles`);
      
      // Remove old particle system
      scene.remove(particles);
      
      // Update particle count and recreate arrays
      particleCount = newParticleCount;
      particlePositions = new Float32Array(particleCount * 3);
      particleVelocities = new Float32Array(particleCount * 3);
      particleSizes = new Float32Array(particleCount);
      
      // Initialize new particles
      initializeParticles();
      
      // Recreate geometry and particle system
      createParticleSystem();
      scene.add(particles);
    }
    
    // Expand bounds to 2.5x the wreck size for realistic sediment field
    const expansion = 2.5;
    const expandedSize = size.multiplyScalar(expansion);
    
    particleBounds.min.copy(center).sub(expandedSize.clone().multiplyScalar(0.5));
    particleBounds.max.copy(center).add(expandedSize.clone().multiplyScalar(0.5));
    
    console.log('Updated particle bounds:', particleBounds);
    
    // Update shader uniforms with new bounds
    if (particleMaterial && particleMaterial.uniforms) {
      particleMaterial.uniforms.boundsMin.value.copy(particleBounds.min);
      particleMaterial.uniforms.boundsMax.value.copy(particleBounds.max);
    }
    
    // Redistribute existing particles within new bounds
    redistributeParticles();
  }
}

// Function to redistribute particles within bounds
function redistributeParticles() {
  const positions = particles.geometry.attributes.position.array;
  
  for (let i = 0; i < particleCount; i++) {
    const i3 = i * 3;
    
    // Random positions within wreck bounds
    positions[i3] = particleBounds.min.x + Math.random() * (particleBounds.max.x - particleBounds.min.x);
    positions[i3 + 1] = particleBounds.min.y + Math.random() * (particleBounds.max.y - particleBounds.min.y);
    positions[i3 + 2] = particleBounds.min.z + Math.random() * (particleBounds.max.z - particleBounds.min.z);
  }
  
  particles.geometry.attributes.position.needsUpdate = true;
}

// Function to initialize particle data with additional attributes for GPU shader
function initializeParticles() {
  // Initialize position, velocity, and size arrays
  for (let i = 0; i < particleCount; i++) {
    const i3 = i * 3;
    
    // Start with default bounds, will be updated when wreck loads
    particlePositions[i3] = particleBounds.min.x + Math.random() * (particleBounds.max.x - particleBounds.min.x);
    particlePositions[i3 + 1] = particleBounds.min.y + Math.random() * (particleBounds.max.y - particleBounds.min.y);
    particlePositions[i3 + 2] = particleBounds.min.z + Math.random() * (particleBounds.max.z - particleBounds.min.z);
    
    // Slow trending velocities for gentle, directional drifting motion
    // Create a subtle underwater current with some random variation
    const baseCurrentX = 0.0001; // Half speed - very slow eastward current
    const baseCurrentY = -0.00005; // Half speed - very slow downward settling
    const baseCurrentZ = 0.00005; // Half speed - very slow northward current
    
    // Add small random variation to the base current (much less random than before)
    particleVelocities[i3] = baseCurrentX + (Math.random() - 0.5) * 0.0002;     // x velocity - half speed with trend
    particleVelocities[i3 + 1] = baseCurrentY + (-Math.random() * 0.0001 - 0.00005); // y velocity - half speed downward trend
    particleVelocities[i3 + 2] = baseCurrentZ + (Math.random() - 0.5) * 0.0002; // z velocity - half speed with trend
    
    // Vary particle sizes - most small, some medium, few large
    const rand = Math.random();
    if (rand < 0.7) {
      particleSizes[i] = 0.03 + Math.random() * 0.02; // Small particles (0.03-0.05)
    } else if (rand < 0.9) {
      particleSizes[i] = 0.05 + Math.random() * 0.03; // Medium particles (0.05-0.08)
    } else {
      particleSizes[i] = 0.08 + Math.random() * 0.04; // Large particles (0.08-0.12)
    }
  }
  
  // Create additional attributes for GPU shader
  const particleIndices = new Float32Array(particleCount);
  for (let i = 0; i < particleCount; i++) {
    particleIndices[i] = i; // Unique index for each particle
  }
  
  // Return data for geometry creation (don't access particles yet)
  return {
    velocities: particleVelocities,
    indices: particleIndices
  };
}

// Function to create particle geometry and system with GPU attributes
function createParticleSystem() {
  particleGeometry.dispose(); // Clean up old geometry
  
  // Set up basic attributes
  particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));  
  particleGeometry.setAttribute('originalSize', new THREE.BufferAttribute(particleSizes, 1));
  
  // Initialize particle data if not already done
  const particleData = initializeParticles();
  
  // Set up GPU shader attributes
  particleGeometry.setAttribute('velocity', new THREE.BufferAttribute(particleData.velocities, 3));
  particleGeometry.setAttribute('particleIndex', new THREE.BufferAttribute(particleData.indices, 1));
  
  // Update particles object with new data (only if particles exists)
  if (particles) {
    particles.geometry = particleGeometry;
    particles.userData = particleData;
  }
}

// Initialize particles with default values
const particleData = initializeParticles();

// Set all particle geometry attributes
particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
particleGeometry.setAttribute('originalSize', new THREE.BufferAttribute(particleSizes, 1));
particleGeometry.setAttribute('velocity', new THREE.BufferAttribute(particleData.velocities, 3));
particleGeometry.setAttribute('particleIndex', new THREE.BufferAttribute(particleData.indices, 1));

// Create a simple circular texture for round particles
const canvas = document.createElement('canvas');
canvas.width = canvas.height = 32; // Small texture for performance
const ctx = canvas.getContext('2d');

// Draw a white circle with soft edges
const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.8)');
gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

ctx.fillStyle = gradient;
ctx.fillRect(0, 0, 32, 32);

const circleTexture = new THREE.CanvasTexture(canvas);
circleTexture.needsUpdate = true;

// GPU-based particle material with custom shaders
const particleMaterial = new THREE.ShaderMaterial({
  uniforms: {
    time: { value: 0 },
    pointTexture: { value: circleTexture },
    color: { value: new THREE.Color(0x8fafbf) }, // Brighter, more visible color
    opacity: { value: 0.8 }, // Even higher opacity for debugging
    size: { value: 0.5 }, // Half the previous size
    boundsMin: { value: new THREE.Vector3(-50, -25, -50) },
    boundsMax: { value: new THREE.Vector3(50, 25, 50) },
    // Fog uniforms
    fogColor: { value: scene.fog.color },
    fogDensity: { value: scene.fog.density }
  },
  vertexShader: `
    uniform float time;
    uniform float size;
    uniform vec3 boundsMin;
    uniform vec3 boundsMax;
    
    attribute float originalSize;
    attribute vec3 velocity;
    attribute float particleIndex;
    
    varying float vOpacity;
    varying float vFogFactor;
    
    void main() {
      // Calculate animated position
      vec3 animatedPosition = position;
      
      // Apply constant velocity drift
      animatedPosition += velocity * time;
      
      // Add very subtle wave motion with slower, more trending patterns
      float waveX = sin(time * 0.0000025 + particleIndex * 0.001) * 0.0000075; // Half speed again, smaller amplitude
      float waveY = cos(time * 0.000002 + particleIndex * 0.0008) * 0.000005; // Half speed again, smaller amplitude  
      float waveZ = sin(time * 0.000003 + particleIndex * 0.0012) * 0.0000075; // Half speed again, smaller amplitude
      animatedPosition += vec3(waveX, waveY, waveZ);
      
      // Boundary wrapping - modulo operation for seamless wrapping
      vec3 boundsSize = boundsMax - boundsMin;
      animatedPosition = boundsMin + mod(animatedPosition - boundsMin, boundsSize);
      
      // Subtle size pulsing - even slower and gentler
      float sizePulse = 1.0 + sin(time * 0.0001 + particleIndex * 0.01) * 0.025; // Half speed again, even smaller variation
      float finalSize = originalSize * sizePulse * size;
      
      // Transform to screen space
      vec4 mvPosition = modelViewMatrix * vec4(animatedPosition, 1.0);
      gl_Position = projectionMatrix * mvPosition;
      
      // Size attenuation - made more visible
      gl_PointSize = finalSize * (800.0 / -mvPosition.z);
      
      // Calculate fog factor for exponential squared fog
      float fogDistance = -mvPosition.z;
      vFogFactor = 1.0 - exp(-fogDistance * fogDistance * 0.0064); // fogDensity squared
      vFogFactor = clamp(vFogFactor, 0.0, 1.0);
      
      // Vary opacity slightly per particle
      vOpacity = 0.8 + sin(particleIndex * 0.1) * 0.2;
    }
  `,
  fragmentShader: `
    uniform sampler2D pointTexture;
    uniform vec3 color;
    uniform float opacity;
    uniform vec3 fogColor;
    
    varying float vOpacity;
    varying float vFogFactor;
    
    void main() {
      // Sample the circular texture
      vec4 textureColor = texture2D(pointTexture, gl_PointCoord);
      
      // Base particle color
      vec3 finalColor = color;
      
      // Apply fog mixing
      finalColor = mix(finalColor, fogColor, vFogFactor);
      
      // Final alpha with texture alpha and fog consideration
      float finalAlpha = textureColor.a * opacity * vOpacity * (1.0 - vFogFactor * 0.8);
      
      gl_FragColor = vec4(finalColor, finalAlpha);
      
      // Alpha test to prevent z-fighting
      if (gl_FragColor.a < 0.01) discard;
    }
  `,
  transparent: true,
  depthWrite: false,
  blending: THREE.NormalBlending,
  fog: false // We handle fog manually in the shader
});

const particles = new THREE.Points(particleGeometry, particleMaterial);
// Store particle data for later use
particles.userData = particleData;
scene.add(particles);

// Loaders setup with better error handling and progress
const draco = new DRACOLoader().setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/libs/draco/');
const ktx2  = new KTX2Loader().setTranscoderPath('https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/libs/basis/').detectSupport(renderer);

const loader = new GLTFLoader();
loader.setDRACOLoader(draco);
loader.setKTX2Loader(ktx2);
loader.setMeshoptDecoder(MeshoptDecoder);

// Add loading indicator
const loadingDiv = document.createElement('div');
loadingDiv.style.cssText = `
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 20px;
  border-radius: 8px;
  font-family: sans-serif;
  z-index: 1000;
  display: none;
`;
loadingDiv.innerHTML = 'Loading model...';
document.body.appendChild(loadingDiv);

// Load the wreck with progress tracking
let wreck = null;

// Function to load a model by key
function loadModel(modelKey) {
  const modelConfig = MODELS[modelKey];
  if (!modelConfig) {
    console.error('Model not found:', modelKey);
    return;
  }
  
  // Remove existing model if present
  if (wreck) {
    scene.remove(wreck);
    wreck = null;
  }
  
  // Show loading indicator
  loadingDiv.innerHTML = `Loading ${modelConfig.name}...`;
  loadingDiv.style.display = 'block';
  
  // Update page title
  document.title = `Virtual Dive ‚Äì ${modelConfig.name}`;
  
  // Update credit display
  const creditText = document.getElementById('creditText');
  if (creditText) {
    creditText.textContent = `Model by ${modelConfig.credit}`;
  }
  
  loader.load(
    modelConfig.url,
    gltf => {
      wreck = gltf.scene;
      
      // Traverse the scene to remove embedded lights and fix materials
      gltf.scene.traverse(obj => {
        if (obj.isLight) {
          obj.visible = false; // nuke embedded lights
          console.log('Disabled embedded light:', obj.name);
        }
        
        // CONSISTENT MATERIAL CLEANING - Remove self-illumination, enable shadows, preserve spotlight response
        if (obj.isMesh && obj.material) {
          // Consistently enable shadow properties for all meshes
          obj.castShadow = true;
          obj.receiveShadow = true;
          
          // Handle both single materials and material arrays
          const materials = Array.isArray(obj.material) ? obj.material : [obj.material];
          
          materials.forEach((material, materialIndex) => {
            console.log('Processing material:', material.type, 'for object:', obj.name);
            
            // Remove all emissive properties but preserve everything else
            if (material.emissive) {
              material.emissive.setHex(0x000000); // Remove emissive color
              console.log('Removed emissive color from:', obj.name);
            }
            if (material.emissiveIntensity !== undefined) {
              material.emissiveIntensity = 0; // Remove emissive intensity
              console.log('Removed emissive intensity from:', obj.name);
            }
            if (material.emissiveMap) {
              material.emissiveMap = null; // Remove emissive texture map
              console.log('Removed emissive map from:', obj.name);
            }
            
            // Remove light maps that might cause self-illumination
            if (material.lightMap) {
              material.lightMap = null;
              console.log('Removed light map from:', obj.name);
            }
            if (material.lightMapIntensity !== undefined) {
              material.lightMapIntensity = 0;
            }
            
            // CONVERT ALL problematic materials to MeshLambertMaterial for consistent lighting
            if (material.type === 'MeshBasicMaterial' || material.type === 'MeshPhongMaterial') {
              console.log(`Converting ${material.type} to MeshLambertMaterial for:`, obj.name);
              
              // Use MeshLambertMaterial which responds consistently to spotlights and shadows
              const newMaterial = new THREE.MeshLambertMaterial({
                map: material.map,                    // Main texture/diffuse map
                color: material.color || new THREE.Color(0xffffff),
                transparent: material.transparent,
                opacity: material.opacity !== undefined ? material.opacity : 1.0,
                alphaMap: material.alphaMap,          // Alpha/transparency map
                side: material.side !== undefined ? material.side : THREE.FrontSide,
                // Copy any other relevant properties
                wireframe: material.wireframe || false,
                vertexColors: material.vertexColors || false,
                fog: material.fog !== undefined ? material.fog : true,
                // Additional texture maps that might be present
                aoMap: material.aoMap,                // Ambient occlusion map
                aoMapIntensity: material.aoMapIntensity || 1.0,
                envMap: material.envMap,              // Environment map
                reflectivity: material.reflectivity || 1.0,
                refractionRatio: material.refractionRatio || 0.98,
                combine: material.combine || THREE.MultiplyOperation
              });
              
              // Force material to update immediately
              newMaterial.needsUpdate = true;
              
              // Replace the material
              if (Array.isArray(obj.material)) {
                obj.material[materialIndex] = newMaterial;
              } else {
                obj.material = newMaterial;
              }
              
              console.log(`Successfully converted to MeshLambertMaterial for: ${obj.name}, with texture: ${!!material.map}`);
            }
            
            // For MeshStandardMaterial and other materials, just clean them without conversion
            else if (material.type === 'MeshStandardMaterial' || material.type === 'MeshPhysicalMaterial') {
              // These materials work well with shadows, just ensure proper settings
              material.needsUpdate = true;
              console.log(`Cleaned ${material.type} for: ${obj.name} (kept original material type)`);
            }
            
            // Force geometry updates for better shadow calculations
            if (obj.geometry) {
              obj.geometry.computeVertexNormals();
              obj.geometry.normalizeNormals();
            }
            
            // Ensure material updates
            const currentMaterial = Array.isArray(obj.material) ? obj.material[materialIndex] : obj.material;
            if (currentMaterial && currentMaterial.needsUpdate !== undefined) {
              currentMaterial.needsUpdate = true;
            }
          });
          
          console.log('Material cleaning complete for:', obj.name, 'Material type:', 
                     Array.isArray(obj.material) ? obj.material.map(m => m.type) : obj.material.type,
                     'Shadows enabled: cast=' + obj.castShadow + ', receive=' + obj.receiveShadow);
        }
      });
      
      scene.add(wreck);
      
      // Force scene update after material changes
      scene.updateMatrixWorld(true);
      
      // Create/recreate spotlight AFTER materials are cleaned
      createSpotlight(); //
      
      // Force a render update to ensure materials are properly applied
      setTimeout(() => {
        if (controllerSpotlight) {
          console.log('Total lights in scene:', scene.children.filter(child => child.isLight).length);
          console.log('Spotlight in scene:', scene.children.includes(controllerSpotlight));
          console.log('Spotlight ready with realistic intensity:', controllerSpotlight.intensity);
        }
      }, 1000);
      
      const box = new THREE.Box3().setFromObject(wreck);
      const sz = box.getSize(new THREE.Vector3()).length();
      const ctr = box.getCenter(new THREE.Vector3());
      wreck.position.sub(ctr); // centre
      
      // Reset camera and controls
      controls.target.set(0, 0, 0);
      camera.position.set(0, sz * 0.3, sz * 0.8);
      
      // Reset VR dolly position
      dolly.position.set(0, 0, 0);
      dolly.rotation.set(0, 0, 0);
      
      // Update particle bounds based on new wreck
      updateParticleBounds();
      
      // Hide loading indicator
      loadingDiv.style.display = 'none';
      
      console.log(`${modelConfig.name} loaded successfully`);
      currentModelKey = modelKey;
    },
    progress => {
      if (progress.lengthComputable) {
        const percentComplete = progress.loaded / progress.total * 100;
        loadingDiv.innerHTML = `Loading ${modelConfig.name}... ${Math.round(percentComplete)}%`;
      }
    },
    err => {
      console.error(`${modelConfig.name} loading failed:`, err);
      loadingDiv.innerHTML = `Failed to load ${modelConfig.name}`;
      loadingDiv.style.color = '#ff6666';
      setTimeout(() => {
        loadingDiv.style.display = 'none';
        loadingDiv.style.color = 'white';
      }, 3000);
    }
  );
}

// Initialize model dropdown
function initializeModelDropdown() {
  const dropdown = document.getElementById('modelDropdown');
  
  // Populate dropdown with models
  Object.entries(MODELS).forEach(([key, config]) => {
    const option = document.createElement('option');
    option.value = key;
    option.textContent = config.name;
    if (key === currentModelKey) {
      option.selected = true;
    }
    dropdown.appendChild(option);
  });
  
  // Handle model selection
  dropdown.addEventListener('change', (event) => {
    const selectedModelKey = event.target.value;
    if (selectedModelKey !== currentModelKey) {
      loadModel(selectedModelKey);
    }
  });
}

// Initialize credit display
const creditText = document.getElementById('creditText');
if (creditText) {
  creditText.textContent = `Model by ${MODELS[currentModelKey].credit}`;
}

// Initialize model dropdown
initializeModelDropdown();

// Load initial model
loadModel(currentModelKey);

// Initialize VR controllers - simplified approach with proper race condition fixes
const controllerModelFactory = new XRControllerModelFactory();
let controller1, controller2, controllerGrip1, controllerGrip2;

// Build two placeholder controllers + grips immediately
const controllers = [];
const controllerGrips = [];

for (let i = 0; i < 2; i++) {
  const ctrl = renderer.xr.getController(i);
  const grip = renderer.xr.getControllerGrip(i);
  grip.add(controllerModelFactory.createControllerModel(grip));

  // Add to scene now ‚Äì they'll be invisible until `connected`
  dolly.add(ctrl);
  dolly.add(grip);

  controllers.push(ctrl);
  controllerGrips.push(grip);
}

// Use the controller's own events
controllers.forEach((ctrl, index) => {
  ctrl.addEventListener('connected', evt => {
    const { handedness, targetRayMode } = evt.data;
    if (targetRayMode !== 'tracked-pointer') return; // skip hands

    // Assign the global refs
    if (handedness === 'left') {
      controller1 = ctrl;
      controllerGrip1 = controllerGrips[index];
    } else if (handedness === 'right') {
      controller2 = ctrl;
      controllerGrip2 = controllerGrips[index];
    }

    ctrl.userData.handedness = handedness;
    ctrl.userData.initialised = true;
    console.log(`‚úÖ ${handedness} controller connected`);
  });

  ctrl.addEventListener('disconnected', () => {
    const hand = ctrl.userData.handedness;
    if (hand === 'left') { controller1 = controllerGrip1 = null; }
    if (hand === 'right') { controller2 = controllerGrip2 = null; }
    console.log(`‚ùå ${hand} controller disconnected`);
  });
});

// Enhanced VR movement - always smooth
function vrMove(dt) {
  const session = renderer.xr.getSession();
  if (!session || session.visibilityState !== 'visible') {
    return;
  }

  // Initialize audio on first VR interaction
  initAudioOnInteraction();

  // Update controller spotlight if right controller is available and spotlight exists
  if (controller2 && controller2.userData.initialised && controllerSpotlight) {
    try {
      // Get world position and quaternion from controller
      const tempMatrix = new THREE.Matrix4();
      tempMatrix.copy(controller2.matrixWorld);
      
      const controllerPosition = new THREE.Vector3();
      const controllerQuaternion = new THREE.Quaternion();
      const controllerScale = new THREE.Vector3();
      
      tempMatrix.decompose(controllerPosition, controllerQuaternion, controllerScale);
      
      // Position spotlight at controller
      controllerSpotlight.position.copy(controllerPosition);
      controllerSpotlight.visible = true;
      
      // Calculate target position 8 meters forward from controller
      const forwardDirection = new THREE.Vector3(0, 0, -1);
      forwardDirection.applyQuaternion(controllerQuaternion);
      
      const targetPosition = controllerPosition.clone();
      targetPosition.add(forwardDirection.multiplyScalar(8));
      
      spotlightTarget.position.copy(targetPosition);
      
      // Debug output every 60 frames
      if (Math.floor(performance.now() / 16) % 60 === 0) {
        console.log('Spotlight Debug:', {
          visible: controllerSpotlight.visible,
          intensity: controllerSpotlight.intensity,
          position: controllerPosition.toArray(),
          target: targetPosition.toArray(),
          distance: controllerSpotlight.distance,
          angle: controllerSpotlight.angle
        });
      }
      
    } catch (error) {
      console.error('Error updating controller spotlight:', error);
    }
  } else {
    // Hide spotlight if right controller is not available or spotlight doesn't exist
    if (controllerSpotlight && controllerSpotlight.visible) {
      controllerSpotlight.visible = false;
      console.log('Spotlight hidden - no controller or spotlight');
    }
  }

  // Early return if controllers aren't ready for movement input
  if (!controller1 || !controller2) {
    return;
  }

  // Track movement state for ramping
  let currentlyMoving = false;
  let isBoosted = false;

  // Process input sources - improved with better error checking
  for (let i = 0; i < session.inputSources.length; i++) {
    const src = session.inputSources[i];
    
    // Enhanced validation - check if controller is fully ready
    if (!src || !src.gamepad || !src.gamepad.buttons || !src.gamepad.axes || src.gamepad.axes.length < 4) {
      continue; // Graceful skipping - continue to next controller if current one isn't ready
    }

    const gamepad = src.gamepad;
    const hand = src.handedness;
    const controller = hand === 'left' ? controller1 : controller2;
    
    // Skip if controller not available
    if (!controller) {
      console.log(`No controller object for ${hand} hand`);
      continue;
    }

    // Movement controls - axes already validated above
    const x = gamepad.axes[2] || 0; // strafe/turn
    const y = gamepad.axes[3] || 0; // walk/fly (-y = forward)

    if (src.handedness === 'left') {
      // Cancel focus animation if user starts moving
      if (focusAnimation && (Math.abs(x) > 0.1 || Math.abs(y) > 0.1)) {
        cancelAnimationFrame(focusAnimation);
        focusAnimation = null;
        console.log('Cancelled focus animation due to left controller movement');
      }
      
      // Speed boost with grip/squeeze (button 1) - add safety check
      const gripButton = gamepad.buttons[1];
      const speedMultiplier = (gripButton && gripButton.pressed) ? 3 : 1;
      
      // Check if boosted for audio
      if (gripButton && gripButton.pressed) {
        isBoosted = true;
      }
      
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0; // Lock to dolly's yaw
      forward.normalize();
      
      const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
      
      // Horizontal movement ONLY (forward/back, strafe)
      if (Math.abs(y) > 0.1) {
        const rampedSpeed = MOVE_SPEED * speedMultiplier * currentSpeed * dt;
        dolly.position.addScaledVector(forward, -y * rampedSpeed); // Negative for forward
        currentlyMoving = true;
      }
      if (Math.abs(x) > 0.1) {
        const rampedSpeed = MOVE_SPEED * speedMultiplier * currentSpeed * dt;
        dolly.position.addScaledVector(right, x * rampedSpeed);
        currentlyMoving = true;
      }
    }
    
    if (src.handedness === 'right') {
      // Cancel focus animation if user starts turning/flying
      if (focusAnimation && (Math.abs(x) > 0.1 || Math.abs(y) > 0.1)) {
        cancelAnimationFrame(focusAnimation);
        focusAnimation = null;
        console.log('Cancelled focus animation due to right controller movement');
      }
      
      // Speed boost with grip/squeeze (button 1) - only for vertical movement
      const gripButton = gamepad.buttons[1];
      const verticalSpeedMultiplier = (gripButton && gripButton.pressed) ? 3 : 1;
      
      // Check if boosted for vertical movement audio
      if (gripButton && gripButton.pressed && Math.abs(y) > 0.1) {
        isBoosted = true;
      }
      
      // Smooth turning with right stick X (no speed boost)
      if (Math.abs(x) > 0.1) {
        dolly.rotation.y -= x * TURN_SPEED * dt; // No speed multiplier for turning
        // Turning doesn't count as movement for audio
      }
      
      // Vertical movement with right stick Y (with speed boost)
      if (Math.abs(y) > 0.1) {
        const rampedSpeed = FLY_SPEED * verticalSpeedMultiplier * currentSpeed * dt;
        dolly.position.y -= y * rampedSpeed;
        currentlyMoving = true;
      }
    }
  }

  // Update target speeds based on input
  targetSpeed = currentlyMoving ? 1.0 : 0.0;
  targetBoostLevel = isBoosted ? 1.0 : 0.0;

  // Smoothly ramp speeds towards targets
  if (currentSpeed < targetSpeed) {
    currentSpeed = Math.min(targetSpeed, currentSpeed + SPEED_RAMP_RATE * dt);
  } else if (currentSpeed > targetSpeed) {
    currentSpeed = Math.max(targetSpeed, currentSpeed - SPEED_RAMP_RATE * dt);
  }

  if (currentBoostLevel < targetBoostLevel) {
    currentBoostLevel = Math.min(targetBoostLevel, currentBoostLevel + BOOST_RAMP_RATE * dt);
  } else if (currentBoostLevel > targetBoostLevel) {
    currentBoostLevel = Math.max(targetBoostLevel, currentBoostLevel - BOOST_RAMP_RATE * dt);
  }

  // Handle movement audio with ramping
  if (currentSpeed > 0.05) { // Small threshold to avoid audio flutter
    if (!isMoving) {
      // Start movement sound
      playMovementSound();
      isMoving = true;
    }
    // Update audio levels based on ramped values
    updateAudioLevels();
  } else {
    if (isMoving) {
      // Stop movement sound
      stopMovementSound();
      isMoving = false;
    }
  }
}

// Add this variable declaration near the top with other variables
let lastTime = 0;

// Performance monitoring for GPU optimization verification
let frameCount = 0;
let performanceStartTime = performance.now();
let averageFrameTime = 0;

// Performance monitoring function
function updatePerformanceStats(currentTime) {
  frameCount++;
  if (frameCount % 60 === 0) { // Every 60 frames (roughly 1 second at 60fps)
    const elapsed = currentTime - performanceStartTime;
    averageFrameTime = elapsed / 60;
    performanceStartTime = currentTime;
    
    // Log performance metrics
    if (frameCount % 300 === 0) { // Every 5 seconds
      console.log(`üöÄ GPU Particle Performance:`, {
        averageFrameTime: `${averageFrameTime.toFixed(2)}ms`,
        targetFrameTime: '16.67ms (60fps)',
        particleCount: particleCount,
        status: averageFrameTime < 16.67 ? '‚úÖ Smooth' : '‚ö†Ô∏è Needs optimization'
      });
    }
  }
}

// Add VR session event listeners to handle mode transitions
renderer.xr.addEventListener('sessionstart', () => {
  console.log('VR session started');
  
  // Detect Quest device and apply optimizations
  const deviceType = detectQuestDevice();
  applyQuestOptimizations(deviceType);
  
  // Recreate spotlight with device-specific optimizations
  if (controllerSpotlight) {
    createSpotlight(35); // Recreate with Quest-specific settings
    controllerSpotlight.visible = false; // Will be enabled when controller is detected
    console.log('Spotlight recreated with device optimizations, intensity:', controllerSpotlight.intensity);
  }
  
  // Initialize audio for VR session
  initAudioOnInteraction();
});

renderer.xr.addEventListener('sessionend', () => {
  console.log('VR session ended');
  
  // Reset camera to full render distance for desktop
  camera.far = 2000;
  camera.updateProjectionMatrix();
  
  // Reset fog to original settings
  scene.fog = new THREE.FogExp2(0x041729, 0.08);
  
  // Reset Quest detection flags
  isQuest2 = false;
  isQuest3 = false;
  
  console.log('üìä Render settings reset to desktop defaults');
  
  // Stop any playing movement sounds
  stopMovementSound();
  isMoving = false;
  
  // Disable controller spotlight
  if (controllerSpotlight) {
    controllerSpotlight.visible = false;
    console.log('Spotlight disabled on session end');
  }
  
  // Get the current camera position from the dolly before resetting
  const vrCameraPosition = new THREE.Vector3();
  camera.getWorldPosition(vrCameraPosition);
  
  // Reset the dolly position and rotation
  dolly.position.set(0, 0, 0);
  dolly.rotation.set(0, 0, 0);
  
  // Set the camera position directly (outside the dolly)
  camera.position.copy(vrCameraPosition);
  
  // Reset orbit controls target
  controls.target.set(0, 0, 0);
  
  // Reset and enable orbit controls
  controls.enabled = true;
  controls.update();
});

// Update the render loop with GPU-optimized particle animation
renderer.setAnimationLoop(time => {
  const t = time;
  const dt = Math.min((time - lastTime) / 1000, 0.1);
  lastTime = time;

  // Performance monitoring
  updatePerformanceStats(t);

  // Update GPU particle shader uniforms (eliminates CPU bottleneck)
  if (particleMaterial && particleMaterial.uniforms) {
    particleMaterial.uniforms.time.value = t;
    
    // Update particle bounds if they've changed
    if (particleBounds) {
      particleMaterial.uniforms.boundsMin.value.copy(particleBounds.min);
      particleMaterial.uniforms.boundsMax.value.copy(particleBounds.max);
    }
  }
  
  // No more CPU particle animation - everything is handled in GPU shaders!
  // This eliminates the 2-3ms CPU bottleneck on Quest-class devices
  
  if (renderer.xr.isPresenting) {
    vrMove(dt);
    controls.enabled = false;
  } else {
    controls.enabled = true;
    controls.update();
  }
  
  renderer.render(scene, camera);
});

// Apply device-specific optimizations on load
const detectedDevice = detectQuestDevice();
applyQuestOptimizations(detectedDevice);
</script>
</body>
</html>
